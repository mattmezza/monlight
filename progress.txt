# Progress & Learnings

## Session 1: Repository Setup

- The monorepo has 5 top-level service directories: `error-tracker/`, `log-viewer/`, `metrics-collector/`, `clients/python/`, `shared/`
- Deployment config lives in `deploy/` with `docker-compose.monitoring.yml` and `secrets.env.example`
- `deploy/data/{errors,logs,metrics}/` directories hold SQLite persistence volumes
- The docker-compose file uses relative build paths (`../error-tracker`, etc.) since it lives in `deploy/`
- The `.gitignore` must cover: Zig (`zig-out/`, `zig-cache/`, `.zig-cache/`), SQLite (`*.db`, `*.db-wal`, `*.db-shm`), Python (`__pycache__/`, `*.egg-info/`, etc.), env files (`secrets.env`, `.env`), and Node (`node_modules/`)
- All three services map internal port 8000 to external ports 5010, 5011, 5012 respectively
- Services connect via the `flowrent_network` external Docker network
- Each service binary supports a `--healthcheck` CLI flag for Docker health checks
- The `env_file` directive in docker-compose points to `secrets.env` (not committed; `secrets.env.example` serves as template)
- Environment variable naming convention: service-specific keys use service name prefix (e.g., `ERROR_TRACKER_API_KEY`), but each service reads it as just `API_KEY` from its own config module

## Session 2: Error Tracker Bootstrap & SQLite Layer

- Zig 0.13 is installed at `/tmp/zig-linux-x86_64-0.13.0/zig` (not in PATH by default)
- In Zig 0.13, `std.Build.Module` does NOT have a `link_library` field. C library linking must be done on the artifact (executable/test) only via `linkSystemLibrary` and `linkLibC`.
- In Zig 0.13, `std.http.Server.Request.respond()` signature is `respond(content, options)` — content ([]const u8) comes FIRST, options struct second. This differs from some later versions.
- The `@cImport` of `sqlite3.h` works with system-installed `sqlite-dev` package on Alpine and `libsqlite3-dev` on Debian/Ubuntu.
- Shared modules (e.g., `shared/sqlite.zig`) are imported into services via `b.addModule("sqlite", .{ .root_source_file = b.path("../shared/sqlite.zig") })` in `build.zig`, then `exe.root_module.addImport("sqlite", sqlite_mod)`.
- Since `build.zig` references `../shared/`, the Dockerfile must use the repo root as Docker build context, not the service directory. Updated docker-compose to use `context: ..` with `dockerfile: error-tracker/Dockerfile`.
- SQLite `execMulti` uses an internal 8KB buffer for null-terminating SQL strings. Migration SQL must fit within this limit.
- In-memory SQLite databases (`:memory:`) use `memory` journal mode, not WAL. Tests that check WAL pragma should account for this.
- SQLite `EXPLAIN QUERY PLAN` returns the detail string in column index 3 — useful for verifying index usage in tests.
- The `_meta` table pattern for schema versioning: `(key TEXT PRIMARY KEY, value TEXT)` with `schema_version` key stores the version as a text string. Migration runner compares version as `usize` integer.

## Session 3: Error Tracker Configuration Module

- Shared config module (`shared/config.zig`) provides generic env var parsing helpers: `getRequired`, `getString`, `getInt`, `getBool`, `getOptional`, `initLogLevel`. Each service's config module uses these to define its own specific config struct.
- Adding a new shared module requires updates in `build.zig`: (1) `b.addModule(...)` to create the module, (2) `exe.root_module.addImport(...)` on the executable, and (3) the same addImport on EVERY test artifact that transitively imports it.
- The shared config module does NOT need `linkSystemLibrary("sqlite3")` or `linkLibC()` since it has no C dependencies — only test artifacts with C deps need those.
- Environment variables in Zig tests cannot be easily set/unset, so config tests rely on verifying behavior with env vars known to NOT exist (e.g., `MONLIGHT_TEST_NONEXISTENT_VAR_12345`) rather than setting them.
- `std.debug.print` is used for fatal startup messages (instead of `std.log`) because log level filtering might suppress the message. Fatal config errors must always be visible.
- Config struct stores a `db_path_z: [*:0]const u8` (null-terminated) alongside the regular `database_path: []const u8` slice, because SQLite's C API requires null-terminated strings. The null-terminated version is backed by a `_db_path_buf: [512]u8` field within the struct.
- IMPORTANT: Previous feature branches are not auto-merged into main. When branching for a new task, branch off the PREVIOUS feature branch (not main) if that branch contains required code (e.g., `shared/sqlite.zig`).
- `std.posix.getenv()` returns `?[]const u8` — an optional slice. It returns null when the env var is not set.
