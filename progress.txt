# Progress & Learnings

## Session 1: Repository Setup

- The monorepo has 5 top-level service directories: `error-tracker/`, `log-viewer/`, `metrics-collector/`, `clients/python/`, `shared/`
- Deployment config lives in `deploy/` with `docker-compose.monitoring.yml` and `secrets.env.example`
- `deploy/data/{errors,logs,metrics}/` directories hold SQLite persistence volumes
- The docker-compose file uses relative build paths (`../error-tracker`, etc.) since it lives in `deploy/`
- The `.gitignore` must cover: Zig (`zig-out/`, `zig-cache/`, `.zig-cache/`), SQLite (`*.db`, `*.db-wal`, `*.db-shm`), Python (`__pycache__/`, `*.egg-info/`, etc.), env files (`secrets.env`, `.env`), and Node (`node_modules/`)
- All three services map internal port 8000 to external ports 5010, 5011, 5012 respectively
- Services connect via the `flowrent_network` external Docker network
- Each service binary supports a `--healthcheck` CLI flag for Docker health checks
- The `env_file` directive in docker-compose points to `secrets.env` (not committed; `secrets.env.example` serves as template)
- Environment variable naming convention: service-specific keys use service name prefix (e.g., `ERROR_TRACKER_API_KEY`), but each service reads it as just `API_KEY` from its own config module

## Session 2: Error Tracker Bootstrap & SQLite Layer

- Zig 0.13 is installed at `/tmp/zig-linux-x86_64-0.13.0/zig` (not in PATH by default)
- In Zig 0.13, `std.Build.Module` does NOT have a `link_library` field. C library linking must be done on the artifact (executable/test) only via `linkSystemLibrary` and `linkLibC`.
- In Zig 0.13, `std.http.Server.Request.respond()` signature is `respond(content, options)` — content ([]const u8) comes FIRST, options struct second. This differs from some later versions.
- The `@cImport` of `sqlite3.h` works with system-installed `sqlite-dev` package on Alpine and `libsqlite3-dev` on Debian/Ubuntu.
- Shared modules (e.g., `shared/sqlite.zig`) are imported into services via `b.addModule("sqlite", .{ .root_source_file = b.path("../shared/sqlite.zig") })` in `build.zig`, then `exe.root_module.addImport("sqlite", sqlite_mod)`.
- Since `build.zig` references `../shared/`, the Dockerfile must use the repo root as Docker build context, not the service directory. Updated docker-compose to use `context: ..` with `dockerfile: error-tracker/Dockerfile`.
- SQLite `execMulti` uses an internal 8KB buffer for null-terminating SQL strings. Migration SQL must fit within this limit.
- In-memory SQLite databases (`:memory:`) use `memory` journal mode, not WAL. Tests that check WAL pragma should account for this.
- SQLite `EXPLAIN QUERY PLAN` returns the detail string in column index 3 — useful for verifying index usage in tests.
- The `_meta` table pattern for schema versioning: `(key TEXT PRIMARY KEY, value TEXT)` with `schema_version` key stores the version as a text string. Migration runner compares version as `usize` integer.

## Session 3: Error Tracker Configuration Module

- Shared config module (`shared/config.zig`) provides generic env var parsing helpers: `getRequired`, `getString`, `getInt`, `getBool`, `getOptional`, `initLogLevel`. Each service's config module uses these to define its own specific config struct.
- Adding a new shared module requires updates in `build.zig`: (1) `b.addModule(...)` to create the module, (2) `exe.root_module.addImport(...)` on the executable, and (3) the same addImport on EVERY test artifact that transitively imports it.
- The shared config module does NOT need `linkSystemLibrary("sqlite3")` or `linkLibC()` since it has no C dependencies — only test artifacts with C deps need those.
- Environment variables in Zig tests cannot be easily set/unset, so config tests rely on verifying behavior with env vars known to NOT exist (e.g., `MONLIGHT_TEST_NONEXISTENT_VAR_12345`) rather than setting them.
- `std.debug.print` is used for fatal startup messages (instead of `std.log`) because log level filtering might suppress the message. Fatal config errors must always be visible.
- Config struct stores a `db_path_z: [*:0]const u8` (null-terminated) alongside the regular `database_path: []const u8` slice, because SQLite's C API requires null-terminated strings. The null-terminated version is backed by a `_db_path_buf: [512]u8` field within the struct.
- IMPORTANT: Previous feature branches are not auto-merged into main. When branching for a new task, branch off the PREVIOUS feature branch (not main) if that branch contains required code (e.g., `shared/sqlite.zig`).
- `std.posix.getenv()` returns `?[]const u8` — an optional slice. It returns null when the env var is not set.

## Session 4: Error Tracker Auth Integration Tests

- Integration tests for HTTP behavior (auth, routing) require spinning up a real TCP server because `std.http.Server.Request` cannot be mocked — it requires a real connection.
- Pattern for HTTP integration tests: create a `TestServer` struct that owns the `net.Server`, start it with a thread that accepts N connections, send raw HTTP requests, parse raw responses. Use port 0 to let the OS assign a free port (avoids conflicts in parallel test runs).
- `handleConnection` must be `pub` in main.zig so that test files (`auth_test.zig`) can import and call it.
- Test files that import `main.zig` (via `@import("main.zig")`) need all the same shared module imports and C library linking as `main.zig` itself in `build.zig`.
- Zig compiler rejects `_ = self;` if `self` was already used earlier in the function — the discard is "pointless" and causes a compile error.
- Deleting `.zig-cache/o/` partially can corrupt the build cache. If the build produces `FileNotFound`, delete the entire `.zig-cache/` directory and rebuild.

## Session 5: Error Tracker Request Limits (Rate Limiting + Body Size)

- In Zig 0.13, the HTTP 413 status code enum is `.payload_too_large`, NOT `.request_entity_too_large`. Always check `/tmp/zig-linux-x86_64-0.13.0/lib/std/http.zig` for the correct enum names.
- The middleware pattern used across the codebase is "call-and-check": each middleware function takes `*std.http.Server.Request` plus its config, sends the error response itself if rejected, and returns an enum the caller checks. This avoids function chaining complexity.
- When adding a new shared module (e.g., `rate_limit`), you must add `addImport` to: (1) the main executable, (2) ALL test artifacts that transitively import it (including test files that `@import("main.zig")` since main.zig now imports the new module).
- Rate limiter uses a ring buffer of timestamps for sliding window tracking. The `max_requests` parameter doubles as the ring buffer size, keeping memory usage proportional to the limit.
- `handleConnection` signature changes (adding parameters) require updating ALL test files that call it. Currently `auth_test.zig` and `rate_limit_test.zig` both call `main.handleConnection(...)`.
- For integration tests of rate limiting, use a `TestServer` that owns the `RateLimiter` with a small limit (e.g., 2-3 requests) to make tests fast and deterministic. Auth tests should use a generous limit (e.g., 1000) so rate limiting doesn't interfere.
- Body size enforcement checks the `Content-Length` header before reading the body, avoiding memory allocation for oversized requests. Requests without `Content-Length` are allowed through (they may have no body or use chunked encoding).

## Session 6: Error Tracker Fingerprinting Algorithm

- The fingerprint module (`fingerprint.zig`) is pure Zig — no C deps (uses `std.crypto.hash.Md5`), no shared module deps. Test artifacts for it don't need `linkSystemLibrary` or `linkLibC`.
- Zig 0.13's `std.crypto.hash.Md5` API: `Md5.init(.{})` → `.update(data)` → `.final(&digest)`. Digest is `[16]u8`. Also has a one-shot `Md5.hash(input, &out, .{})`.
- Python traceback parsing: the `File "...", line N` format always has `", line "` (with the comma+space) immediately after the closing quote of the file path. The optional `, in function_name` part comes after the line number.
- The fingerprint key format is `{project}:{exception_type}:{file}:{line}` — the MD5 hasher can be fed these parts incrementally with `.update()` calls (including the `:` separators) rather than needing to allocate a concatenated string.
- When no traceback location can be parsed (non-Python tracebacks or plain text), the fallback uses the entire traceback string as the location component, still producing a deterministic 32-char hex fingerprint.

## Session 7: Error Tracker Error Ingestion Endpoint

- The `error_ingestion.zig` module handles: JSON parsing/validation, fingerprint-based deduplication (create/increment/reopen), occurrence record creation, and occurrence trimming (max 5 per error).
- `std.json.parseFromSliceLeaky` is preferred over `parseFromSlice` when using an arena allocator — it skips tracking individual allocations since the arena will free them all at once.
- The ingestion flow: parse JSON → validate required fields + length limits → compute fingerprint → find existing error by fingerprint → create/increment/reopen → create occurrence → trim occurrences. All DB operations are sequential (no transactions needed for single-row operations).
- `handleConnection` signature grew to include `db: *sqlite.Database` and `cfg: *const app_config.Config` so the error ingestion handler can access the database and config (e.g., Postmark settings for email alerts).
- When `handleConnection` signature changes, ALL test files that call it must be updated. Test files need `makeTestConfig()` helper functions that create dummy Config structs with valid field values.
- The `Config` struct has a `_db_path_buf: [512]u8` field that backs the null-terminated `db_path_z` pointer. When creating test configs, this buffer must be properly initialized with `@memcpy` and null terminator.
- Body size enforcement tests that previously used `POST /api/errors` had to be changed to `POST /api/test` (which returns 404) because the error ingestion handler now tries to read the request body. If `Content-Length` claims N bytes but none are sent, the server hangs waiting for data.
- The Postmark email integration builds JSON payloads manually using `std.ArrayList(u8)` writer with a `writeJsonEscaped` helper that escapes `"`, `\\`, `\n`, `\r`, `\t`, and control chars below 0x20.
- `std.http.Client` in Zig 0.13: create with `{ .allocator = allocator }`, `open(.POST, uri, .{ .server_header_buffer, .extra_headers })`, set `.transfer_encoding = .{ .content_length = len }`, then `send()` → `writeAll(payload)` → `finish()` → `wait()`.
- Email alerting is fire-and-forget: failures are logged with `log.warn` but never propagate errors back to the HTTP response. If Postmark credentials are not configured (`null`), the alert is skipped silently with an early return.

## Session 8: Error Listing Endpoint

- The `error_listing.zig` module handles GET /api/errors with query parameter parsing, dynamic SQL construction, and JSON response formatting.
- Since Zig doesn't support runtime string concatenation for SQL queries easily, the approach uses 4 separate prepared statement variants (no filters, project only, environment only, both) rather than dynamically building a single SQL string. This is verbose but safe and avoids SQL injection.
- Query parameter parsing uses `std.mem.splitScalar` to split on `&`, then `std.mem.indexOf` to find `=` separators. No URL decoding is implemented yet (not needed for the current use case).
- `std.fmt.parseInt(u32, value, 10)` is used for parsing numeric query params like `limit` and `offset`, with `catch continue` to skip invalid values gracefully.
- The listing endpoint returns a two-query pattern: first a `SELECT COUNT(*)` for the total, then a `SELECT ... LIMIT ? OFFSET ?` for the paginated data. Both queries use the same filter conditions.
- Routing in `main.zig` distinguishes GET vs POST on `/api/errors` by checking the HTTP method after matching the path prefix. The `isApiErrorsPath()` helper matches both `/api/errors` (exact) and `/api/errors?...` (with query string).
- JSON response is built manually with `std.ArrayList(u8)` writer rather than using `std.json` serialization, to have full control over the output format and avoid needing to define Zig structs that match the exact JSON shape.

## Session 9: Error Detail Endpoint

- The `error_detail.zig` module handles GET /api/errors/{id} — returns full error group data plus the last 5 occurrences with request context.
- Routing in `main.zig`: within the GET `/api/errors` branch, `error_detail.extractId(target)` is checked first. If it returns an ID, the request is routed to `handleErrorDetail`; otherwise it falls through to `handleErrorListing`.
- `isApiErrorsPath()` was updated to also match `/api/errors/` sub-paths by adding a `rest[0] == '/'` check.
- Zig 0.13 type coercion quirk: `ArrayList(u8).toOwnedSlice()` returns `![]u8`, which does NOT implicitly coerce to `!?[]const u8` (optional + const). You must assign to an intermediate `const result: []const u8 = try buf.toOwnedSlice();` and then `return result;` — the `[]const u8` → `?[]const u8` coercion works, but `[]u8` → `?[]const u8` does not coerce through error union payloads directly.

## Session 10: Error Tracker Resolve Endpoint

- The `error_resolve.zig` module handles POST /api/errors/{id}/resolve — marks an error as resolved with `resolved=1` and `resolved_at` timestamp.
- Routing for POST resolve must be checked BEFORE the GET `/api/errors/{id}` branch in `main.zig`, since `isApiErrorsPath()` would also match `/api/errors/42/resolve`. The resolve check uses `error_resolve.extractResolveId()` which specifically matches the `/api/errors/{id}/resolve` pattern.
- The `extractResolveId` function is separate from `extractId` in `error_detail.zig` — it specifically looks for the `/resolve` suffix after the ID segment. This is cleaner than trying to make `extractId` handle both cases.
- Idempotent resolve: if the error is already resolved, the endpoint returns 200 without modifying `resolved_at`. This avoids updating the timestamp on every call and preserves the original resolution time.
- The resolve endpoint uses a tagged union `ResolveResult` (`.resolved` or `.not_found`) rather than an optional, making the handler code in `main.zig` clearer about which HTTP status code to return.
- Tests for `API_KEY`-dependent modules (main.zig, auth_test.zig, rate_limit_test.zig) require setting `API_KEY=test_key_123` in the environment when running `zig build test`.

## Session 11: Projects Listing Endpoint

- The `projects_listing.zig` module handles GET /api/projects — returns distinct project names from the errors table as `{"projects": ["flowrent", ...]}`.
- `Statement.deinit()` and `RowIterator.deinit()` both call `sqlite3_finalize` on the same underlying statement pointer. Calling both causes a double-free segfault. Pattern: only call `stmt.deinit()`, never `iter.deinit()` when you own the statement. This is the correct ownership pattern throughout the codebase.
- Routing for `/api/projects` must be placed BEFORE the `/api/errors` catch-all in `main.zig`, since `isApiErrorsPath()` would not match it, but ordering still matters for clarity and to avoid future conflicts with broader path matchers.
- The `isApiProjectsPath()` helper follows the same pattern as `isApiErrorsPath()`: matches `/api/projects` exactly or `/api/projects?...` with query string.
- The JSON response is built manually with `ArrayList(u8)` writer, consistent with the pattern established in `error_listing.zig` and `error_detail.zig`.
