# Monlight — Web / Frontend Monitoring Implementation Plan

- Browser Relay service (`browser-relay/`)
  - Bootstrap Zig project
    - ~~Create `build.zig` and `build.zig.zon` with SQLite C library dependency (for source map storage)~~
      - ~~`zig build` succeeds and produces a binary~~
    - ~~Create `Dockerfile` (multi-stage: Alpine + Zig build → Alpine runtime with sqlite-libs)~~
      - ~~`docker build` produces a working image under 20MB~~
    - ~~Create `src/main.zig` with HTTP server skeleton listening on port 8000~~
      - ~~Server starts and responds to requests~~
  - ~~SQLite database layer~~
    - ~~Implement SQLite initialization using shared SQLite module~~
      - ~~Database file is created at configurable `DATABASE_PATH`~~
      - ~~WAL mode, busy timeout, and pragmas applied automatically by shared module~~
    - ~~Create schema migrations:~~
      - ~~Migration 1: `dsn_keys` table (id, public_key, project, created_at, active)~~
        - ~~Table is created on first startup~~
        - ~~`public_key` column is unique and indexed~~
      - ~~Migration 2: `source_maps` table (id, project, release, file_url, map_content, uploaded_at)~~
        - ~~Table is created on first startup~~
        - ~~Composite unique index on (project, release, file_url)~~
      - ~~Migration 3: Indexes: `idx_dsn_public_key`, `idx_source_map_lookup` on (project, release, file_url)~~
        - ~~Indexes exist and are used by query planner~~
  - ~~Configuration module~~
    - ~~Parse environment variables: `DATABASE_PATH`, `ADMIN_API_KEY`, `ERROR_TRACKER_URL`, `ERROR_TRACKER_API_KEY`, `METRICS_COLLECTOR_URL`, `METRICS_COLLECTOR_API_KEY`, `CORS_ORIGINS`, `MAX_BODY_SIZE`, `RATE_LIMIT`, `LOG_LEVEL`~~
      - ~~All variables are read from env~~
      - ~~Missing required variables (`ADMIN_API_KEY`, `ERROR_TRACKER_URL`, `ERROR_TRACKER_API_KEY`, `METRICS_COLLECTOR_URL`, `METRICS_COLLECTOR_API_KEY`) cause a clear startup error~~
      - ~~Defaults are applied for optional variables~~
  - ~~DSN / public key authentication~~
    - ~~Implement public key validation for browser ingestion endpoints~~
      - ~~Requests must include `X-Monlight-Key` header with a valid public key from `dsn_keys` table~~
      - ~~Invalid or missing key returns 401 with `{"detail": "Invalid DSN key"}`~~
      - ~~Public key lookup resolves to a project name (used to tag ingested data)~~
    - ~~Implement admin API key authentication for management endpoints (source map upload, DSN key management)~~
      - ~~Uses shared auth middleware with `ADMIN_API_KEY` via `X-API-Key` header~~
      - ~~`/health` endpoint is excluded from auth~~
  - ~~CORS handling~~
    - ~~Implement CORS middleware for browser ingestion endpoints~~
      - ~~Read allowed origins from `CORS_ORIGINS` env var (comma-separated)~~
      - ~~Respond with `Access-Control-Allow-Origin` matching the request origin (if in allowed list)~~
      - ~~Respond with `Access-Control-Allow-Headers: X-Monlight-Key, Content-Type`~~
      - ~~Respond with `Access-Control-Allow-Methods: POST, OPTIONS`~~
      - ~~Preflight `OPTIONS` requests return 204 with CORS headers~~
      - ~~Non-matching origins are rejected (no CORS headers sent)~~
  - ~~Request limits~~
    - ~~Use shared rate limiting middleware (300 requests/minute per public key)~~
      - ~~Rate-limited requests return 429~~
    - ~~Use shared body size enforcement (64KB max for browser payloads)~~
      - ~~Oversized requests return 413~~
  - ~~Browser error ingestion endpoint (`POST /api/browser/errors`)~~
    - ~~Parse and validate JSON request body:~~
      - ~~Required fields: `type` (string, e.g. "Error", "TypeError"), `message` (string), `stack` (string)~~
      - ~~Optional fields: `url` (page URL), `user_agent` (string), `session_id` (string), `context` (object with arbitrary metadata), `release` (string for source map matching), `timestamp` (ISO8601, defaults to server time)~~
      - ~~Invalid JSON returns 400~~
      - ~~Missing required fields return 400 with descriptive error~~
    - ~~If `release` is provided, attempt source map deobfuscation of stack trace~~
      - ~~Parse stack frames from the JS stack trace string~~
      - ~~For each frame, look up source map by (project, release, file_url)~~
      - ~~If found, map minified line:column to original file:line:column using source map~~
      - ~~Replace stack trace with deobfuscated version~~
      - ~~If source map not found, use the raw stack trace as-is~~
    - ~~Transform browser error into Error Tracker payload format:~~
      - ~~Map `type` → `exception_type`~~
      - ~~Map `message` → `message`~~
      - ~~Map deobfuscated `stack` → `traceback`~~
      - ~~Map `url` → `request_url`~~
      - ~~Set `request_method` to `"BROWSER"`~~
      - ~~Set `project` from DSN key lookup~~
      - ~~Set `environment` from `context.environment` if present, else `"prod"`~~
      - ~~Pack `user_agent`, `session_id`, and remaining `context` fields into `extra`~~
    - ~~Forward transformed payload to Error Tracker via HTTP POST to `{ERROR_TRACKER_URL}/api/errors`~~
      - ~~Include `X-API-Key: {ERROR_TRACKER_API_KEY}` header~~
      - ~~Timeout: 5 seconds~~
      - ~~On success, return the Error Tracker response to the browser (201 or 200)~~
      - ~~On Error Tracker failure, log warning and return 502 with `{"detail": "Upstream error"}`~~
  - ~~Browser metrics ingestion endpoint (`POST /api/browser/metrics`)~~
    - ~~Parse and validate JSON request body:~~
      - ~~Required fields: `metrics` (array of metric objects)~~
      - ~~Each metric object: `name` (required string), `type` (required: "counter", "histogram", "gauge"), `value` (required number)~~
      - ~~Optional per-metric fields: `labels` (object), `timestamp` (ISO8601)~~
      - ~~Optional top-level fields: `session_id` (string), `url` (string, page URL)~~
      - ~~Invalid JSON returns 400~~
      - ~~Missing required fields return 400 with descriptive error~~
    - ~~Enrich metric labels:~~
      - ~~Add `project` label from DSN key lookup~~
      - ~~Add `source: "browser"` label to distinguish from server-side metrics~~
      - ~~If `session_id` provided, add `session_id` label~~
      - ~~If `url` provided, add `page` label (URL path only, strip query params and fragment)~~
    - ~~Transform into Metrics Collector payload format and forward via HTTP POST to `{METRICS_COLLECTOR_URL}/api/metrics`~~
      - ~~Include `X-API-Key: {METRICS_COLLECTOR_API_KEY}` header~~
      - ~~Timeout: 5 seconds~~
      - ~~On success, return 202 with `{"status": "accepted", "count": N}`~~
      - ~~On Metrics Collector failure, log warning and return 502 with `{"detail": "Upstream error"}`~~
  - ~~Source map upload endpoint (`POST /api/source-maps`)~~
    - ~~Authenticate with admin API key (`X-API-Key` header)~~
    - ~~Parse multipart form or JSON body with fields:~~
      - ~~`project` (required string)~~
      - ~~`release` (required string, version identifier e.g. "1.2.3" or git SHA)~~
      - ~~`file_url` (required string, the URL the minified JS is served from, e.g. "/static/app.min.js")~~
      - ~~`map_content` (required string, the source map JSON content)~~
    - ~~Validate source map is valid JSON with `version`, `sources`, `mappings` fields~~
      - ~~Invalid source map returns 400 with `{"detail": "Invalid source map format"}`~~
    - ~~Store in `source_maps` table (upsert on project+release+file_url)~~
      - ~~Return 201 with `{"status": "uploaded", "project": "...", "release": "...", "file_url": "..."}`~~
  - ~~Source map list endpoint (`GET /api/source-maps`)~~
    - ~~Authenticate with admin API key~~
    - ~~Support query parameters: `project` (optional filter)~~
    - ~~Return list of uploaded source maps (without map_content, just metadata)~~
      - ~~Response shape: `{"source_maps": [{"id": N, "project": "...", "release": "...", "file_url": "...", "uploaded_at": "..."}], "total": N}`~~
  - ~~Source map delete endpoint (`DELETE /api/source-maps/{id}`)~~
    - ~~Authenticate with admin API key~~
    - ~~Delete source map by ID~~
      - ~~Return 200 with `{"status": "deleted"}`~~
      - ~~Non-existent ID returns 404~~
  - ~~Source map deobfuscation module~~
    - ~~Implement JavaScript stack trace parser~~
      - ~~Parse common stack trace formats:~~
        - ~~Chrome/V8: `    at functionName (file.js:line:col)`~~
        - ~~Firefox: `functionName@file.js:line:col`~~
        - ~~Safari: `functionName@file.js:line:col`~~
      - ~~Extract file URL, line number, column number from each frame~~
    - ~~Implement source map decoder (VLQ-encoded mappings)~~
      - ~~Parse source map JSON (version 3 format)~~
      - ~~Decode Base64 VLQ-encoded `mappings` field~~
      - ~~Build lookup table: (generated_line, generated_col) → (original_file, original_line, original_col, original_name)~~
      - ~~Support `sources`, `names`, and `sourcesContent` fields~~
    - ~~Implement stack trace rewriting~~
      - ~~For each parsed frame, query source map lookup~~
      - ~~Replace minified file:line:col with original file:line:col~~
      - ~~Preserve function name from source map `names` if available~~
      - ~~Return rewritten stack trace as string~~
  - ~~DSN key management endpoints~~
    - ~~`POST /api/dsn-keys` — Create a new DSN key~~
      - ~~Authenticate with admin API key~~
      - ~~Required field: `project` (string)~~
      - ~~Generate random 32-character hex public key~~
      - ~~Insert into `dsn_keys` table with `active=true`~~
      - ~~Return 201 with `{"public_key": "...", "project": "..."}`~~
    - ~~`GET /api/dsn-keys` — List all DSN keys~~
      - ~~Authenticate with admin API key~~
      - ~~Return list of DSN keys with project, active status, created_at~~
      - ~~Response shape: `{"keys": [{"id": N, "public_key": "...", "project": "...", "active": true, "created_at": "..."}]}`~~
    - ~~`DELETE /api/dsn-keys/{id}` — Deactivate a DSN key~~
      - ~~Authenticate with admin API key~~
      - ~~Set `active=false` (soft delete, so existing references break gracefully)~~
      - ~~Return 200 with `{"status": "deactivated"}`~~
      - ~~Non-existent ID returns 404~~
  - ~~Health check endpoint (`GET /health`)~~
    - ~~Return `{"status": "ok"}` with 200, no auth required~~
      - ~~Endpoint responds without any API key~~
  - ~~Data retention cleanup~~
    - ~~Implement background job that deletes source maps older than configurable retention period (default 90 days)~~
      - ~~Job runs periodically (e.g., daily)~~
      - ~~Only source maps beyond retention are deleted~~
      - ~~DSN keys are never auto-deleted~~
  - Tests
    - ~~Write tests for DSN key validation (valid key resolves to project, invalid key rejected, deactivated key rejected)~~
      - ~~Tests pass with `zig build test`~~
    - ~~Write tests for CORS middleware (allowed origin, disallowed origin, preflight OPTIONS)~~
      - ~~Tests cover all CORS scenarios~~
    - ~~Write tests for browser error payload transformation (field mapping, environment extraction, extra packing)~~
      - ~~Tests verify correct transformation to Error Tracker format~~
    - ~~Write tests for browser metrics enrichment (label injection, URL path extraction, project tagging)~~
      - ~~Tests verify correct label enrichment~~
    - ~~Write tests for source map parsing (VLQ decoding, mapping lookup)~~
      - ~~Tests verify correct line:col mapping with known source maps~~
    - ~~Write tests for stack trace parsing (Chrome, Firefox, Safari formats)~~
      - ~~Tests cover all three major browser formats~~
    - ~~Write tests for stack trace rewriting (end-to-end: minified stack → deobfuscated stack)~~
      - ~~Tests verify full pipeline from raw stack to rewritten stack~~
    - ~~Write tests for rate limiting (accept under limit, reject over limit per public key)~~
      - ~~Tests verify 429 response when rate limit exceeded~~
    - ~~Write tests for upstream forwarding failure handling (Error Tracker down, Metrics Collector down)~~
      - ~~Tests verify 502 responses and graceful degradation~~

- ~~Error Tracker service modifications (`error-tracker/`)~~
  - ~~Extend error ingestion to handle browser-sourced errors~~
    - ~~Accept `request_method: "BROWSER"` as a valid value (currently expects HTTP methods)~~
      - ~~Browser errors are stored and displayed like server errors~~
    - ~~Accept `extra` field containing `user_agent`, `session_id`, and arbitrary browser context~~
      - ~~Extra fields are stored in `error_occurrences` and displayed in the detail view~~
    - ~~No changes to fingerprinting algorithm (exception_type + stack location still works for JS errors)~~
      - ~~Verify fingerprinting works with deobfuscated JS stack traces~~
        - ~~JS stack frames with `file.js:line` format produce consistent fingerprints~~
  - ~~Extend Web UI for browser errors~~
    - ~~Add source filter (server / browser / all) to error listing page~~
      - ~~Filter uses `request_method = 'BROWSER'` to distinguish browser errors~~
      - ~~Default view shows all errors (both server and browser)~~
    - ~~Display browser-specific context in error detail view~~
      - ~~Show user agent, page URL, session ID when present~~
      - ~~Show session ID as a grouping hint (link to other errors from same session)~~
  - ~~Tests~~
    - ~~Write tests for browser error ingestion (BROWSER method accepted, extra fields stored)~~
      - ~~Tests pass with `zig build test`~~
    - ~~Write tests for fingerprinting with JS stack traces~~
      - ~~Tests verify consistent fingerprints for typical JS stack formats~~

- Metrics Collector service modifications (`metrics-collector/`)
  - ~~Extend dashboard to show Web Vitals~~
    - ~~Add "Web Vitals" section to dashboard page~~
      - ~~Display current LCP, INP, CLS values (latest hourly averages)~~
      - ~~Color-code values: green (good), yellow (needs improvement), red (poor) using Google's thresholds~~
        - ~~LCP: good < 2.5s, poor > 4.0s~~
        - ~~INP: good < 200ms, poor > 500ms~~
        - ~~CLS: good < 0.1, poor > 0.25~~
    - ~~Add Web Vitals trend chart (LCP, INP, CLS over time)~~
      - ~~Chart shows p75 values over the selected time period (p75 is the standard Web Vitals reporting percentile)~~
      - ~~Time range selector (1h, 24h, 7d) applies to Web Vitals charts~~
    - ~~Add page performance breakdown table~~
      - ~~Columns: page (URL path), LCP p75, INP p75, CLS p75, page views~~
      - ~~Sorted by page views descending~~
      - ~~Filterable by page URL~~
  - ~~Extend dashboard data endpoint (`GET /api/dashboard`)~~
    - ~~Add `web_vitals` section to response:~~
      - ~~`summary`: current LCP, INP, CLS averages and ratings~~
      - ~~`timeseries`: LCP, INP, CLS p75 over time buckets~~
      - ~~`by_page`: per-page Web Vitals breakdown~~
    - ~~Only include `web_vitals` section if browser metrics exist (check for `source: "browser"` label)~~
      - ~~If no browser metrics, omit the section entirely (backward compatible)~~
  - ~~No changes to ingestion, aggregation, or storage~~
    - ~~Browser metrics use the same metrics pipeline (counter, histogram, gauge)~~
    - ~~Web Vitals are ingested as histogram metrics with `source: "browser"` label~~
    - ~~Existing aggregation (minute → hourly) and retention policies apply~~
  - ~~Tests~~
    - ~~Write tests for dashboard endpoint with Web Vitals data present~~
      - ~~Tests verify `web_vitals` section appears when browser metrics exist~~
    - ~~Write tests for dashboard endpoint with no browser metrics~~
      - ~~Tests verify `web_vitals` section is omitted (backward compatible)~~

- JavaScript SDK (`clients/js/`)
  - ~~Package scaffolding~~
    - ~~Create `package.json` with package metadata, build scripts, and dev dependencies~~
      - ~~Package name: `@monlight/browser`~~
      - ~~Package is buildable with `npm run build`~~
    - ~~Create `tsconfig.json` for TypeScript compilation~~
      - ~~Target: ES2020, module: ESNext~~
    - ~~Set up build pipeline (TypeScript → bundled JS)~~
      - ~~Use `esbuild` for bundling (fast, produces small output)~~
      - ~~Build produces:~~
        - ~~`dist/monlight.min.js` — UMD bundle for script tag usage (self-initializing via `window.MonlightConfig`)~~
        - ~~`dist/monlight.esm.js` — ES module for npm import~~
        - ~~`dist/monlight.d.ts` — TypeScript declarations~~
      - ~~Total bundle size under 5KB gzipped~~
    - ~~Create directory structure: `src/core.ts`, `src/errors.ts`, `src/metrics.ts`, `src/network.ts`, `src/vitals.ts`, `src/session.ts`, `src/transport.ts`, `src/types.ts`~~
      - ~~All source files compile without errors~~
  - ~~Core module (`src/core.ts`)~~
    - ~~Implement `init(config)` function~~
      - ~~Config options:~~
        - ~~`dsn` (required string): public key for authentication~~
        - ~~`endpoint` (required string): Browser Relay URL (e.g., "https://monitoring.example.com")~~
        - ~~`release` (optional string): app version for source map matching~~
        - ~~`environment` (optional string, default "prod")~~
        - ~~`sampleRate` (optional number, 0.0-1.0, default 1.0): sampling rate for performance data~~
        - ~~`debug` (optional boolean, default false): enable console debug logging~~
        - ~~`beforeSend` (optional callback): transform or drop events before sending~~
        - ~~`enabled` (optional boolean, default true): master kill switch~~
      - ~~Validate required config fields, throw Error if missing~~
      - ~~Initialize all sub-modules (errors, metrics, network, vitals, session)~~
      - ~~Return a `MonlightClient` instance~~
    - ~~Implement `MonlightClient` class with methods:~~
      - ~~`captureError(error: Error, context?: object)` — manually report an error~~
      - ~~`captureMessage(message: string, level?: string)` — report a message as an error~~
      - ~~`setUser(userId: string)` — associate a user ID with subsequent events~~
      - ~~`addContext(key: string, value: any)` — add persistent context to all events~~
      - ~~`destroy()` — tear down all listeners and flush pending data~~
    - ~~UMD bundle auto-initializes from `window.MonlightConfig` if present~~
      - ~~`<script>` tag usage: set `window.MonlightConfig = {dsn: "...", endpoint: "..."}` before loading the script~~
      - ~~SDK reads config, calls `init()`, and exposes the client as `window.Monlight`~~
  - ~~Session module (`src/session.ts`)~~
    - ~~Generate anonymous session ID (UUID v4) on first page load~~
      - ~~Store in `sessionStorage` so it persists across navigations within the same tab~~
      - ~~Generate a new session ID when a new tab is opened~~
      - ~~Never use cookies or persistent storage~~
    - ~~Expose `getSessionId()` function~~
      - ~~Returns the current session ID string~~
    - ~~Include `session_id` in all error and metric payloads~~
  - ~~Error capture module (`src/errors.ts`)~~
    - ~~Install global error handlers on `init()`:~~
      - ~~`window.addEventListener("error", handler)` for uncaught exceptions~~
        - ~~Extract error type, message, stack trace, and source file/line/col from ErrorEvent~~
      - ~~`window.addEventListener("unhandledrejection", handler)` for unhandled promise rejections~~
        - ~~Extract reason (Error object or string) from PromiseRejectionEvent~~
    - ~~Implement error deduplication~~
      - ~~Track last N error fingerprints (type + message + first stack frame) in memory~~
      - ~~Skip sending duplicate errors within a 60-second window~~
      - ~~Reset dedup cache on page navigation~~
    - ~~Build error payload and send via transport module~~
      - ~~Payload shape matches `POST /api/browser/errors` schema~~
      - ~~Include `release` from config for source map matching~~
      - ~~Include current page URL, user agent, session ID~~
      - ~~Call `beforeSend` callback if configured; drop event if callback returns null~~
    - ~~Provide `destroy()` to remove global listeners~~
  - ~~Console capture module (integrated into `src/errors.ts`)~~
    - ~~Optionally patch `console.error` and `console.warn`~~
      - ~~Enabled via config option `captureConsole` (default: false)~~
      - ~~Wrap original console methods; call original + capture the message~~
    - ~~Convert console.error calls into error reports~~
      - ~~Set `type` to "ConsoleError", `message` to the console arguments stringified~~
      - ~~Include a synthetic stack trace from `new Error().stack`~~
    - ~~Convert console.warn calls into error reports with lower severity~~
      - ~~Set `type` to "ConsoleWarning"~~
    - ~~Restore original console methods on `destroy()`~~
  - ~~Performance / Web Vitals module (`src/vitals.ts`)~~
    - ~~Measure Core Web Vitals using browser Performance APIs:~~
      - ~~**LCP** (Largest Contentful Paint): use `PerformanceObserver` with `entryType: "largest-contentful-paint"`~~
        - ~~Report final LCP value after page becomes hidden (`visibilitychange` event)~~
      - ~~**INP** (Interaction to Next Paint): use `PerformanceObserver` with `entryType: "event"` (duration ≥ 40ms)~~
        - ~~Track highest interaction duration per page, report on page hide~~
      - ~~**CLS** (Cumulative Layout Shift): use `PerformanceObserver` with `entryType: "layout-shift"` (exclude user-input)~~
        - ~~Accumulate layout shift values using session windows (gap > 1s or total > 5s starts new window)~~
        - ~~Report max session window value on page hide~~
    - ~~Measure additional performance metrics:~~
      - ~~**TTFB** (Time to First Byte): from `PerformanceNavigationTiming.responseStart`~~
      - ~~**FCP** (First Contentful Paint): from `PerformanceObserver` with `entryType: "paint"`~~
      - ~~**Page load time**: from `PerformanceNavigationTiming.loadEventEnd - navigationStart`~~
    - ~~Apply client-side sampling~~
      - ~~On `init()`, generate a random number; if > `sampleRate`, skip all performance measurement~~
      - ~~Sampling decision is per page load (consistent within a session page)~~
    - ~~Send Web Vitals as histogram metrics via the metrics transport:~~
      - ~~`web_vitals_lcp` (histogram, value in milliseconds)~~
      - ~~`web_vitals_inp` (histogram, value in milliseconds)~~
      - ~~`web_vitals_cls` (histogram, value as float, e.g. 0.05)~~
      - ~~`web_vitals_ttfb` (histogram, value in milliseconds)~~
      - ~~`web_vitals_fcp` (histogram, value in milliseconds)~~
      - ~~`page_load_time` (histogram, value in milliseconds)~~
      - ~~Labels: `page` (URL path)~~
    - ~~Provide `destroy()` to disconnect all PerformanceObservers~~
  - ~~Network monitoring module (`src/network.ts`)~~
    - ~~Intercept `fetch` API:~~
      - ~~Wrap `window.fetch` to record request start time, URL, method~~
      - ~~On response: record status code, duration~~
      - ~~On error: record failure~~
      - ~~Report failed requests (network error or status >= 500) as errors:~~
        - ~~`type`: "NetworkError"~~
        - ~~`message`: `"{method} {url} failed with status {status}"` or `"{method} {url} network error: {error_message}"`~~
      - ~~Report all requests as metrics:~~
        - ~~`browser_http_requests_total` (counter, labels: method, status, host)~~
        - ~~`browser_http_request_duration_ms` (histogram, labels: method, status, host)~~
      - ~~Restore original `fetch` on `destroy()`~~
    - ~~Intercept `XMLHttpRequest`:~~
      - ~~Wrap `XMLHttpRequest.prototype.open` and `XMLHttpRequest.prototype.send`~~
      - ~~Record method, URL, start time on `open`/`send`~~
      - ~~Record status, duration on `loadend` event~~
      - ~~Same error/metric reporting as fetch~~
      - ~~Restore original XHR methods on `destroy()`~~
    - ~~URL sanitization:~~
      - ~~Strip query parameters and fragments from reported URLs (privacy)~~
      - ~~Collapse URL path segments that look like IDs (UUIDs, numeric IDs) into `{id}` (e.g., `/api/users/123/profile` → `/api/users/{id}/profile`)~~
    - ~~Exclude monitoring endpoints from interception:~~
      - ~~Do not intercept requests to the `endpoint` URL (the Browser Relay itself)~~
      - ~~This prevents infinite loops of monitoring requests being monitored~~
  - ~~Transport module (`src/transport.ts`)~~
    - ~~Implement batched beacon transport:~~
      - ~~Buffer error and metric payloads in memory~~
      - ~~Flush on interval (every 5 seconds) or when buffer exceeds 10 items~~
      - ~~Use `navigator.sendBeacon()` for `visibilitychange`/`pagehide` flushes (reliable on page unload)~~
      - ~~Use `fetch()` with `keepalive: true` for interval-based flushes~~
      - ~~Fall back to synchronous XHR if `sendBeacon` and `fetch` are unavailable~~
    - ~~Include `X-Monlight-Key` header (public key from DSN config) in all requests~~
      - ~~Note: `sendBeacon` uses `Blob` with content type `application/json` (cannot set custom headers); for beacon, include key as query parameter `?key={dsn}`~~
    - ~~Separate error and metric payloads:~~
      - ~~Errors: POST to `{endpoint}/api/browser/errors` (sent individually, not batched, for immediate visibility)~~
      - ~~Metrics: POST to `{endpoint}/api/browser/metrics` (batched for efficiency)~~
    - ~~Handle transport failures gracefully:~~
      - ~~On failure, discard the payload (don't retry, don't queue)~~
      - ~~Log warning to console if `debug` mode is enabled~~
    - ~~Provide `flush()` and `destroy()` methods~~
  - ~~Type definitions (`src/types.ts`)~~
    - ~~Export TypeScript interfaces for all config options, payloads, and public API~~
      - ~~`MonlightConfig` interface~~
      - ~~`MonlightClient` interface~~
      - ~~`BrowserError` interface~~
      - ~~`BrowserMetric` interface~~
  - ~~Script tag integration~~
    - ~~UMD bundle self-initializes from `window.MonlightConfig`~~
    - ~~Usage example:~~
      ```html
      <script>
        window.MonlightConfig = {
          dsn: "your-public-key",
          endpoint: "https://monitoring.example.com",
          release: "1.0.0",
          sampleRate: 0.1
        };
      </script>
      <script src="/static/monlight.min.js" defer></script>
      ```
    - ~~After initialization, client is accessible as `window.Monlight`~~
      - ~~`window.Monlight.captureError(new Error("test"))` works from console~~
      - ~~`window.Monlight.setUser("user-123")` works from application code~~
  - ~~npm package integration~~
    - ~~Usage example:~~
      ```js
      import { init } from "@monlight/browser";

      const client = init({
        dsn: "your-public-key",
        endpoint: "https://monitoring.example.com",
        release: "1.0.0",
      });

      // Manual error capture
      client.captureError(new Error("Something went wrong"));
      ```
    - ~~Tree-shakeable: unused modules can be excluded by bundlers~~
  - Tests
    - ~~Write unit tests for session ID generation and persistence~~
      - ~~Tests verify UUID format, sessionStorage persistence, new ID per tab context~~
    - ~~Write unit tests for error capture (window.onerror, unhandledrejection, manual captureError)~~
      - ~~Tests verify correct payload construction from Error objects~~
      - ~~Tests verify deduplication suppresses repeated errors~~
    - ~~Write unit tests for console capture (console.error wrapping, restore on destroy)~~
      - ~~Tests verify console methods are wrapped and restored~~
    - ~~Write unit tests for Web Vitals collection (LCP, INP, CLS measurement)~~
      - ~~Tests mock PerformanceObserver and verify correct metric emission~~
      - ~~Tests verify sampling rate is applied~~
    - ~~Write unit tests for network interception (fetch, XHR wrapping, URL sanitization)~~
      - ~~Tests verify fetch/XHR are intercepted and metrics recorded~~
      - ~~Tests verify monitoring endpoint is excluded from interception~~
      - ~~Tests verify URL sanitization (query stripping, ID collapsing)~~
    - ~~Write unit tests for transport (batching, beacon fallback, flush on visibility change)~~
      - ~~Tests verify batching behavior and flush triggers~~
      - ~~Tests verify sendBeacon is used on page hide~~
    - ~~Write unit tests for beforeSend callback (transform event, drop event)~~
      - ~~Tests verify callback can modify or suppress events~~
    - ~~Write integration tests for full init → capture → transport pipeline~~
      - ~~Tests verify end-to-end flow from error occurrence to transport call~~

- ~~Deployment updates (`deploy/`)~~
  - ~~Update `docker-compose.monitoring.yml`~~
    - ~~Add `browser-relay` service definition~~
      - ~~Port mapping: 5013:8000~~
      - ~~Volume mount for SQLite persistence: `./data/browser-relay:/app/data`~~
      - ~~Environment variables: `DATABASE_PATH`, `ADMIN_API_KEY`, `ERROR_TRACKER_URL` (http://error-tracker:8000), `ERROR_TRACKER_API_KEY`, `METRICS_COLLECTOR_URL` (http://metrics-collector:8000), `METRICS_COLLECTOR_API_KEY`, `CORS_ORIGINS`~~
      - ~~`env_file` references `secrets.env`~~
      - ~~Health check configured~~
      - ~~Connected to `flowrent_network`~~
      - ~~Depends on `error-tracker` and `metrics-collector` services~~
  - ~~Update `secrets.env.example`~~
    - ~~Add `BROWSER_RELAY_ADMIN_API_KEY` placeholder~~
    - ~~Add `CORS_ORIGINS` placeholder (e.g., `https://rentyourbikevalencia.com,https://www.rentyourbikevalencia.com`)~~
  - ~~Update nginx config documentation~~
    - ~~Add browser relay proxy section:~~
      - ~~`/browser-relay/` → `http://127.0.0.1:5013/`~~
      - ~~Note: this endpoint must be publicly accessible (no basic auth) for browser SDK to reach it~~
      - ~~TLS termination at nginx~~
  - ~~Update `deploy/backup.sh`~~
    - ~~Add browser relay database backup (source maps are valuable)~~
      - ~~`sqlite3 /path/to/data/browser-relay/browser-relay.db ".backup $BACKUP_DIR/browser-relay-$DATE.db"`~~
  - ~~Update `deploy/upgrade.sh`~~
    - ~~Add browser-relay to the rolling restart sequence~~
    - ~~Add health check: `curl http://localhost:5013/health`~~

- ~~End-to-end validation~~
  - ~~Extend `docker-compose.test.yml` or smoke test script~~
    - ~~Browser Relay starts and responds to `/health`~~
    - ~~Create a DSN key via `POST /api/dsn-keys` with admin key~~
    - ~~Submit a browser error via `POST /api/browser/errors` with DSN public key → returns 201~~
    - ~~Submit browser metrics via `POST /api/browser/metrics` with DSN public key → returns 202~~
    - ~~Verify error appears in Error Tracker (`GET /api/errors` on :5010) with `request_method: "BROWSER"`~~
    - ~~Verify metrics appear in Metrics Collector (check for `source: "browser"` labeled metrics)~~
    - ~~Upload a source map via `POST /api/source-maps` → returns 201~~
    - ~~Submit a browser error with matching `release` → verify stack trace is deobfuscated in Error Tracker~~
    - ~~Verify CORS headers are present on browser relay responses~~
    - ~~Verify rate limiting works (send 301+ requests, expect 429)~~
    - ~~Graceful shutdown works (send SIGTERM, verify clean exit within 10 seconds)~~

- ~~CI/CD updates (`.github/workflows/`)~~
  - ~~Extend Zig services workflow~~
    - ~~Add `browser-relay` to the build matrix~~
      - ~~Run `zig build test` for browser-relay~~
      - ~~Build Docker image for browser-relay~~
      - ~~Verify Docker image size is under 20MB~~
      - ~~Push image to GHCR on main branch~~
  - ~~Create workflow for JavaScript SDK~~
    - ~~Trigger on push to main and pull requests (when `clients/js/` changes)~~
      - ~~Workflow runs only when JS client files change~~
    - ~~Install Node.js dependencies~~
    - ~~Run TypeScript type checking (`tsc --noEmit`)~~
    - ~~Run tests (`npm test`)~~
    - ~~Run build (`npm run build`)~~
    - ~~Verify bundle size is under 5KB gzipped~~
      - ~~CI step runs `gzip -c dist/monlight.min.js | wc -c` and fails if size exceeds 5120 bytes~~
    - ~~Optionally publish to npm on tagged releases~~
      - ~~Package version matches git tag~~
